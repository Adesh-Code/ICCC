import { Meta } from "@storybook/addon-docs";

<Meta
  title="Digital HIG/Documentation/Contributing/Testing strategy"
  parameters={{
    viewMode: "docs",
    previewTabs: {
      canvas: { hidden: true }
    }
  }}
/>

# Testing strategy

Use this document as a guide to understand the how and why of the Digital HIG testing effort.

## Table of contents

- [Motivation](#motivation)
- [Testing strategy](#testing-strategy)
- [Unit tests with Jest](#unit-tests-with-jest)
  - [How to run Jest tests](#how-to-run-jest-tests)
  - [Unit test coverage](#unit-test-coverage)
- [Visual regression tests with Applitools](#visual-regression-tests-with-applitools)
  - [Dashboard access](#dashboard-access)
  - [What to do if snapshot does not match baseline](#what-to-do-if-snapshot-does-not-match-baseline)
  - [How to run Applitools tests](#how-to-run-applitools-tests)
- [Functional tests with Cypress](#functional-tests-with-cypress)
- [Useful links](#useful-links)

## Motivation

> When there is more than one developer making changes actively to the codebase, issues and bugs tend to arise.
> Therefore, it would be good to have preventive actions taken before introducing any problems into the codebase.

— [Start Testing Your JavaScript Code with Jest](https://dev.to/ohdylan/start-testing-your-javascript-codes-with-jest-2gfm)

Thus, testing is of utmost importance to ensure the functionality of each component and the quality of its code. Testing ensures that you can contribute to the codebase without affecting the development of cohesive, accurate, and accessible experiences using Digital HIG components.

## Testing strategy

The purpose of the Digital HIG testing strategy is to:

- Define the general approach to be employed when testing
- Introduce the tooling we use
- Provide instructions to run, create, and maintain different kinds of tests
- Define how to evaluate the results of testing

### Testing pyramid

The project testing strategy is loosely based on [Martin Fowler’s **_Testing Pyramid_**](https://martinfowler.com/bliki/TestPyramid.html).

> The test pyramid is a way of thinking about how different kinds of automated tests should be used to create a balanced portfolio.

In the context of Digital HIG, the pyramid has three layers: unit tests, visual regression tests, and end-to-end/integration tests.

![Digital HIG Testing pyramid](./images/testing-strategy/001.png)
🟡 TODO: Resize all images.

To implement this strategy in the Digital HIG context:

- We write unit tests for each individual module and control unit test coverage using automated tools.
- We write visual regression tests to ensure changes do not affect the visual presentation of components.
- We have a [ref-app](https://pages.git.autodesk.com/dpe/iccc/#/) separated from our documentation code that resembles how a consuming team would use Digital HIG components. We write integration tests for this codebase.

## Unit tests with Jest

Unit tests act as a safety net where you can isolate and exercise specific pieces of your code (functions, methods, or Digital HIG components).
The goal is to guarantee that each unit of code performs as expected and does not break any existing functionality, even after making changes.

Unit tests are created following the AAA pattern:

> The Arrange, Act and Assert Pattern is a way of structuring unit tests so that they are easy to read and understand.
>
> Arrange: Set up the conditions for your test. This might involve creating objects, setting up variables or anything else that’s required for your test.
>
> Act: This is where you actually execute the code that you are testing.
>
> Assert: Verify that the code you’re testing behaves as expected. This might involve checking the value of a variable, or verifying that a certain method was called.

— [Arrange, Act and Assert Pattern: The Three A’s of Unit Testing](https://robertmarshall.dev/blog/arrange-act-and-assert-pattern-the-three-as-of-unit-testing/)

We use [Jest](https://jestjs.io/) to write our unit tests. It is a popular JavaScript test runner that provides a wide variety of methods and functionalities. It lets you access the DOM via jsdom, which is an approximation of how the browser works.

Unit tests are included per component, and are run every time a developer commits new code, as well as during the PR build process on the server. We use [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/).

> The more your tests resemble the way your software is used, the more confidence they can give you.

— [Testing Library - Guiding Principles](https://testing-library.com/docs/guiding-principles/)

### How to run Jest tests

The first time you are running tests locally, you need to run the build to compile dependencies:

```bash
yarn build
```

To run your tests once:

```bash
yarn test
```

To run your tests and open the [Jest watch mode](https://jestjs.io/docs/cli) (enables you to specify the name or path to a file to focus on a specific set of tests):

```bash
yarn test:watch
```

### Snapshot testing

> Snapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.

- [Snapshot Testing with Jest](https://jestjs.io/docs/snapshot-testing#snapshot-testing-with-jest)

If snapshot tests fail as a result of an expected UI change, they can be updated by running:

```bash
yarn test -u
```

The generated or modified snapshot files must be added to your commit. Note: do not update the snapshots blindly if the change was not expected.

### Unit test coverage

The amount of code that is exercised by our unit tests is called test coverage. On every commit and every time we run the tests, we can see the coverage report as part of the test run in the terminal with CLI.

![Jest coverage threshold](./images/testing-strategy/006.png)

To see an HTML report, we can go the root of the project, navigate to the `coverage` folder, and open the `index.html` file in a browser.

The component file (following the pattern `component.js.html`) can also be opened in the browser. It provides a more detailed breakdown, which is especially useful if full coverage is not initially reached:

![Jest typography coverage not met](./images/testing-strategy/010.png)
![Jest coverage report title](./images/testing-strategy/011.png)
![Jest coverage report breakdown](./images/testing-strategy/012.png)

The coverage threshold for Digital HIG components is configured to meet 100%.

### How to write component tests with Jest

Following the AAA pattern mentioned at the start of this section is a good starting point for writing unit tests for Digital HIG components. We generally start with an arrange function explicitly declared as such. For example:

```javascript
import React from "react";
import Tabs from "./tabs";
import { fireEvent, render, screen, waitFor } from "@testing-library/react";

import { themeLight } from '@iccc/theme-mui';
import { createTheme, ThemeProvider } from '@mui/material/styles';

const light = createTheme(themeLight);

const arrange = ({
  tabProperties = [{ label: "label" }],
  ...otherProps
} = {}) => {
  const utils = render(
    <ThemeProvider theme={light}>
      <Tabs tabProperties={tabProperties} {...otherProps} />
    </ThemeProvider>
  );
  return utils;
};
```

This enables us to arrange our tests with the same basic set of props without duplication, passing in additional props as needed. The three steps are clearly visible, as can be seen in this example:

```javascript
describe("Tabs component", () => {
  it("accepts classnames", () => {
    arrange({
      className: "foo"
    });
    const tab = screen.getByRole("tab");
    expect(tab).toHaveClass("foo");
  });
});
```

As well as reaching 100% coverage, unit tests should also test for accessibility. For more information on this, see our ["Accessibility Implementation and Validation"](/docs/iccc-documentation-contributing-accessibility-implementation-and-validation--page#testing-accessibility-capabilities-in-unit-tests) guide.

## Visual regression tests with Applitools

> Visual testing evaluates the visible output of an application and compares that output against the results expected by design.
> In other words, it helps catch “visual bugs” in the appearance of a page or screen, which are distinct from strictly functional bugs.
> Automated visual testing tools like Applitools, can help speed this visual testing up and reduce errors that are occur with manual verification.

— ["What is Visual Testing?", Applitools blog](https://applitools.com/blog/visual-testing/)

The first PR build will fail and trigger the visual regression stage of the pipeline. We recommend skipping the VR in the build parameters for the first run of the PR build. This will allow you to get a staging link, which will be posted in the Slack channel [#priv-cfp-dhig-notifs](https://autodesk.slack.com/archives/C022QV9UQ9H). It can be found using the corresponding PR number.

### Dashboard access

![Applitools Eyes dashboard](./images/testing-strategy/003.png)

You can access the Applitools Eyes dashboard from here:
[https://autodeskeyes.applitools.com/app/test-results/00000251764056604522/?accountId=u1MMjmZ1jEuuJ_f1DV5aNg~~](https://autodeskeyes.applitools.com/app/test-results/00000251764056604522/?accountId=u1MMjmZ1jEuuJ_f1DV5aNg~~)

The visual regression tests results are also logged to the Jenkins console.
![Jenkins console output for visual regression tests](./images/testing-strategy/005.png)

The tests are divided into PR, branch, and ref-app batches. Each batch has its test group where you can see which tests passed or failed.

### What to do if snapshot does not match baseline

In case the snapshot does not match the baseline, the best way to check what exactly happened is to refer to the dashboard and click on the unresolved test(s) for closer inspection.

![Applitools Eyes dashboard](./images/testing-strategy/004.png)
![Applitools Eyes unresolved test](./images/testing-strategy/013.png)

The "root cause analysis" tool (clicked in the screenshot above) can be used to inspect the source of the differences. If the changes are unexpected/undesired, there is no further action to take in Applitools, and the discrepancy should be remedied in the code itself. If the changes were intentional, the changes can be approved in Applitools.

### How to approve visual changes

This process should be done just before you merge your PR with the master branch, so make sure all PR requested changes are done first.

1. Ensure on Applitools dashboard that the changes present in the tests are as expected (changes are highlighted in fuchsia).
2. Announce in the [#priv-cfp-dhig-engineering](https://autodesk.slack.com/archives/C021XHN55CL) Slack channel that you are going to update the baseline. This is to warn the other engineers of the upcoming changes to avoid potential conflicts and enable them to rebase once the merge is finished.
3. Return to the Applitools dashboard and select each one of the tests that you want to approve, then click the thumbs-up icon.
4. Once you have approved all tests, click the save button. This will save the changes in the baseline.

### How to run Applitools tests

- If you want to run the Applitools VR separate from the pipeline, you can trigger a test run from your local codebase. This command will run the tests for all the components in the `packages` folder. The command is:

```js
// The API key is acquired from Digital HIG engineers.
APPLITOOLS_API_KEY='SAMPLE-API-KEY' yarn test:vr
```

- If you want to run the tests for a specific component (in the below example we are running the tests for the `packages/Typography` component), you can run the following command:

```js
// The API key is acquired from Digital HIG engineers.
APPLITOOLS_API_KEY='SAMPLE-API-KEY' yarn test:vr --storyTitle="Typography"
```

## Functional tests with Cypress

End to end/integration testing is concerned with validating if our published component can be used to build a user experience.

We use [Cypress](https://www.cypress.io/) in our [ref-app](https://pages.git.autodesk.com/dpe/iccc/#/). We validate the following:

- The packages we publish to the node package repository (Artifactory) can be pulled in as dependencies to build a working user interface
- Each component works as per requirements
- How they interact with each other in an environment

### How to run:

- Navigate to ref-app folder and start the server:

```bash
cd packages/ref-app && yarn start
```

- Run Cypress tests from UI dashboard with Applitools disabled:

```bash
yarn cy:open
```

**Note:** Once the Cypress UI dashboard loads, click on "Running # integration specs" on the right-hand side.
![Cypress dashboard](./images/testing-strategy/007.png)
![Cypress test running](./images/testing-strategy/008.png)

- Run Cypress tests from headless mode with Applitools disabled:

```bash
yarn cy:run
```

![Completed headless Cypress run in terminal](./images/testing-strategy/009.png)

## Useful links

- [Applitools - What is Functional Testing?](https://applitools.com/blog/functional-testing-guide/)
- [Marin Fowler - UnitTest](https://martinfowler.com/bliki/UnitTest.html)
- [JavaScript Testing Best Practices](https://github.com/goldbergyoni/javascript-testing-best-practices)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [ReactJS - Testing Overview](https://reactjs.org/docs/testing.html)
- [ReactJS - Testing Recipes](https://reactjs.org/docs/testing-recipes.html)
- [Kent C. Dodds - Common mistakes with React Testing Library](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)
- [Kent C. Dodds - Testing ⚛️ components using render props](https://kentcdodds.com/blog/testing-components-using-render-props)
